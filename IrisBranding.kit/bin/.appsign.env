#!/bin/bash

########################################################################
#
# App Signing Functions
#
# 2016 BroadSoft, Inc.
#
# This file contains common fuctions used by both the branding and
# signing scripts.
#
########################################################################

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define App Signing Variables
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# version constant; this should be updated each time the scripts are
# modified
declare -r VERSION="3.9.18.1"

# these constants define the dependency version requirements
declare -r OSXVER="10.11.6"
declare -r XCODEVER="8.2.1"

# constants
declare -r RE_SDK="iphoneos([0-9.]+)"
declare -r RE_BUNDLE_VERSION="^([0-9]+)(\.[0-9]+){0,3}$"
declare -r RE_SHORT_VERSION="^[0-9]+\.[0-9]+\.[0-9]+$"
declare -r RE_LEADING_ZEROS="(^0+[0-9]*)|(\.0+[0-9]+)"
declare -r RE_ITUNESART="^iTunesArtwork(@2x)?(\.png)?$"
declare -r RE_APPEX="^(.+)\.appex$"

# command constants
declare -r UNAME=/usr/bin/uname
declare -r SWVERS=/usr/bin/sw_vers
declare -r XCODEBUILD=/usr/bin/xcodebuild
declare -r SECURITY=/usr/bin/security
declare -r OPENSSL=/usr/bin/openssl
declare -r CODESIGN=/usr/bin/codesign

declare -r ZIP=/usr/bin/zip
declare -r UNZIP=/usr/bin/unzip

# static variables (set once, used throughout)
declare -i DEBUG=0
declare -i PROMPTS=1
declare LOG
declare APP
declare BUNDLEID
declare WORKDIR
declare PROFILE
declare PROFILEPLIST
declare CERTNAME
declare IPAROOT
declare PAYLOADDIR
declare SUPPORTDIR
declare APPDIR
declare PLUGINSDIR
declare INFOPLIST
declare BUNDLEID
declare BUNDLENAME
declare MINOSVER
declare SDKVER
declare RESRULES
declare ENTITLEMENTS
declare -a APPLANGS
declare -a SWIFT_LIBS
declare -a APPEXS
declare -a WEB_CREDENTIALS_ASSOCIATED_DOMAINS

declare -i DEVICE_SUPPORTED_IPHONE=0
declare -i DEVICE_SUPPORTED_IPAD=0
declare -i DEVICE_SUPPORTED_UNIVERSAL=0
declare -i SWIFT_SUPPORTED=0

# distribution flags
declare -i APPSTORE_DIST=0

# global return variable (needed for some operations that cannot
# be completed gracefully as part of a subshell)
declare globalReturnValue

declare -r ENVIRONMENTBASE="${SCRIPTDIR}/.appbase.env"

source "${ENVIRONMENTBASE}"
test $? -eq 0 || \
  { echo "failed to load environment: ${ENVIRONMENTBASE}"; exit 1; }

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Error Exit
#
# Exits the script with an error message and error code.
#
# $1: error message
# $2: exit code
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function errExit ()
{
  echo -e "error ${2}: ${1}"
  exit $2
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Version Comparison Function
#
# Compares two versions that are formed as period-separated integers.
#
# $1: first version
# $2: second version
# returns 0: $1 == $2
#         1: $1 > $2
#         2: $1 < $2
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function vercomp ()
{
  if [[ $1 == $2 ]]
  then
    return 0
  fi
  local IFS=.
  local i ver1=($1) ver2=($2)
  # fill empty fields in ver1 with zeros
  for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
  do
    ver1[i]=0
  done
  for ((i=0; i<${#ver1[@]}; i++))
  do
    if [[ -z ${ver2[i]} ]]
    then
      # fill empty fields in ver2 with zeros
      ver2[i]=0
    fi
    if ((10#${ver1[i]} > 10#${ver2[i]}))
    then
      return 1
    fi
    if ((10#${ver1[i]} < 10#${ver2[i]}))
    then
      return 2
    fi
  done
  return 0
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Assert Signing Environment
#
# Verifies the enviornment is suitable to continue for app signing.
#
# exits on error
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function assertSigningEnvironment ()
{
  assertAppBaseEnvironment

  test -x $SWVERS || \
    errExit "cannot find the ${$SWVERS} command" 1

  test "$($SWVERS -productName)" = "Mac OS X" || \
    test "$($SWVERS -productName)" = "macOS" || \
    errExit "this script can only be executed on Mac OS X" 1

  vercomp "$OSXVER" "$($SWVERS -productVersion)"
  local -i rc=$?; test $rc -ne 1 || \
    errExit "Mac OS X ${OSXVER} or newer is required to execute this script" 1

  if [ -x $XCODEBUILD ]
  then
    vercomp "$XCODEVER" "$($XCODEBUILD -version | awk '{ if (NR == 1) print $2 }')"
    rc=$?; test $rc -ne 1 || \
    errExit "Xcode ${XCODEVER} or newer is required to execute this script" 1
  else
    echo "warning:The Xcode environment is not found; codesigning issues may occur."
  fi

  test -x $SECURITY || \
    errExit "cannot find the ${SECURITY} command" 1

  test -x $OPENSSL || \
    errExit "cannot find the ${OPENSSL} command" 1

  test -x $CODESIGN || \
    errExit "cannot find the ${CODESIGN} command" 1

  test -x $G || \
    errExit "cannot find the ${PLB} command" 1

  test -x $ZIP || \
    errExit "cannot find the ${ZIP} command" 1

  test -x $UNZIP || \
    errExit "cannot find the ${UNZIP} command" 1
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Pick List
#
# Implements a pick list.  Normally, one would use the select built-in,
# but for some reason, it seems to display the prompts on stderr which
# is a problem when the debug logging is turned on (the prompts end up
# in the error log file and not on the the screen).
#
# $1: the prompt
# $n: one or more choices
# returns the index of the selected choice
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function pickList ()
{
  local prompt="$1"; shift
  local choices=( "$@" )
  local re='^[0-9]+$'  # only allow the user to select numbers
  local -i count=0
  local pick=""

  echo "$prompt"

  while [ -z "$pick" ]
  do
    count=0
    for choice in "${choices[@]}"
    do
      (( count++ ))
      echo "${count}) ${choice}"
    done
    echo -n "Choice [1-${count}]: "
    read pick
    echo $pick >> "$LOG"

    if [[ $pick =~ $re ]]
    then
      if [ $pick -ge 1 -a $pick -le $count ]
      then
        count=$pick
        return $(( count-1 ))
      fi
    fi
    echo "Invalid selection.  <CTRL-c> to abort."
    pick=""
  done

  return -1
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Certificate Common Name
#
# Extracts the Common Name from a specified certificate in the given
# provisioning profile.
#
# $1: the provisioning profile
# $2: the optional certificate index; 0 if unspecified
# echos the common name; returns the return code
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function certificateCommonName ()
{
  local -i index=0
  test -n "$2" && index=$2

  # this has to use PlistBuddy directly and not through a function
  # due to the special characters in the certificate
  $PLB -c "Print :DeveloperCertificates:${index}" "$1" | \
    $OPENSSL x509 -inform DER -noout -subject | \
    /usr/bin/sed -E 's/.*CN=([^/]+).*/\1/'

  return $?
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Decode Provisioning Profile
#
# Decodes the Provisioning Profile into a text Plist version.
#
# Required Global Variables:
#   PROFILE  (read)
#   WORKDIR  (read)
#   PROFILEPLIST  (set)
#   APPSTORE_DIST
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function decodeProvisioningProfile ()
{
  echo -e "Decoding the provisioning profile:\n\t${PROFILE}"

  PROFILEPLIST="${WORKDIR}/$(basename ${PROFILE}).plist"
  $SECURITY cms -D -i "${PROFILE}" -o "${PROFILEPLIST}"
  local -i rc=$?; (( rc == 0 )) || \
    errExit "failed to decode ${PROFILE}" $rc

  # determine if this is an App Store distribution
  local taskAllow=$(readPlistValue "$PROFILEPLIST" "Entitlements:get-task-allow" "false")
  if [ "$taskAllow" = "true" ]
  then
    # developer distribution profile
    APPSTORE_DIST=0
    return 0
  fi

  # need to look for devices
  local devices=$(readPlistValue "$PROFILEPLIST" "ProvisionsAllDevices" "false")
  if [ "$devices" = "true" ]
  then
    # enterprise disribution profile
    APPSTORE_DIST=0
    return 0
  fi

  devices=$(readPlistValue "$PROFILEPLIST" "ProvisionedDevices" "false")
  if [ "$devices" = "false" ]
  then
    # task-allow is false, and there are no device entries: AppStore
    APPSTORE_DIST=1
  else
    # enterprise ad-hoc profile
    APPSTORE_DIST=0
  fi
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Choose Code Signing Certificate
#
# Extracts the code signing cerfificate from the provisioning profile.
# If more than one certificate exist, the user is prompted to choose
# one.
#
# Required Global Variables:
#   PROFILEPLIST  (read)
#   CERTNAME  (set)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function chooseCodeSigningCertificate ()
{
  if [ -n "$CERTNAME" ]
  then
    echo "Extracting the code signing certificate named \"${CERTNAME}\" ..."
  else
    echo "Extracting the code signing certificate(s) ..."
  fi

  # get the certificate count
  local -i count=$(countPlistArrayValues "$PROFILEPLIST" "DeveloperCertificates" "data")
  local -i max=count-1
  local -i rc=$?; (( rc == 0 )) || \
    errExit "failed to get certificate count" $rc

  # pick a certificate indentified by the provisioning profile
  local cn=""
  if [ $count -le 0 ]
  then
    errExit "no code signing certificates found in provisioning profile" 1
  elif [ -n "$CERTNAME" ]
  then
    # look for a named cert
    for i in $(eval echo {0..$max})
    do
      cn=$(certificateCommonName "$PROFILEPLIST" $i)
      rc=$?; (( rc == 0 )) || errExit "failed to extract certificate" $rc

      # normalize any hexidicimal escapes (e.g. é encoded as \xC3\xA9)
      cn=$(printf "$cn")

      # check for a match
      if [ "$cn" = "$CERTNAME" ]
      then
        break  # found
      else
        cn=""  # this is not a match
      fi
    done
    # validate
    test -n "$cn" || errExit "failed to find certificate ${CERTNAME}" 1
  elif [ $count -eq 1 ]
  then
    # the profile contains a single certificate
    cn=$(certificateCommonName "$PROFILEPLIST")
    rc=$?; (( rc == 0 )) || errExit "failed to extract certificate" $rc

    # normalize any hexidicimal escapes (e.g. é encoded as \xC3\xA9)
    cn=$(printf "$cn")
  else
    # the profile contains many certificates; prompt the user to pick one
    if (( PROMPTS == 1 ))
    then
      local -a cnarray;
      for i in $(eval echo {0..$max})
      do
        cnarray[$i]=$(certificateCommonName "$PROFILEPLIST" $i)
        rc=$?; (( rc == 0 )) || errExit "failed to extract certificate" $rc

        # normalize any hexidicimal escapes (e.g. é encoded as \xC3\xA9)
        cnarray[$i]=$(printf "${cnarray[$i]}")
      done

      pickList \
        "Multiple certificates can sign this application; choose one." \
        "${cnarray[@]}"
      cn="${cnarray[$?]}"
    else
      errExit "multiple signing certificates found; re-execute in prompt mode" 1
    fi
  fi

  echo -e "Verifying code signing identity for certificate:\n\t\"${cn}\""

  # now that a certificate common name has been chosen, verify that a valid
  # code signing identity is actually installed in the user's keychain
  local IFS=$NL
  local -a identities=( $($SECURITY find-identity -v -p codesigning | /usr/bin/sed -E 's/.*"(.+)".*/\1/') )
  rc=$?
  unset IFS
  (( rc == 0 )) || errExit "failed to find signing identities" $rc

  # loop the the identities for one that matches the certificate common name
  local i
  for i in "${identities[@]}"
  do
    if [ "$i" = "$cn" ]
    then
      CERTNAME="$cn"
      break
    fi
  done

  test -n "$CERTNAME" || \
    errExit "no valid code signing identity is installed for certificate!" 1
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Prepare IPA Root
#
# Prepares the IPA root for updates by either copying the .app or
# unzipping the .ipa file.
#
# Required Global Variables:
#   APP (read)
#   WORKDIR  (read)
#   IPAROOT  (set)
#   APPNAME  (set)
#   APPDIR  (set)
#   PLUGINSDIR  (set)
#   PAYLOADDIR  (set)
#   SUPPORTDIR  (set)
#   INFOPLIST  (set)
#   APPLANGS  (set)
#   SWIFT_SUPPORTED  (set)
#   SWIFT_LIBS  (set)
#   APPEXS  (set)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function prepareIpaRoot ()
{
  IPAROOT="${WORKDIR}/iparoot"
  PAYLOADDIR="${IPAROOT}/Payload"
  local -i rc=0

  if [ -d "$APP" ]
  then
    echo -e "Creating application archive directory:\n\t${APP} ->\n\t${IPAROOT}"
    /bin/mkdir -p "$PAYLOADDIR"
    rc=$?; (( rc == 0 )) || \
      errExit "failed to create application archive payload directory" $rc
    # make a copy of the app contents
    /bin/cp -Rp "$APP" "$PAYLOADDIR"
    rc=$?; (( rc == 0 )) || \
      errExit "failed to copy application contents" $rc
  else
    echo -e "Extracting application archive:\n\t${APP} ->\n\t${IPAROOT}"
    $UNZIP -q -d "$IPAROOT" "$APP"
    rc=$?; (( rc == 0 )) || \
      errExit "failed extract application archive" $rc
  fi

  APPDIR="${PAYLOADDIR}/$(/bin/ls "$PAYLOADDIR")"
  rc=$?; (( rc == 0 )) || \
    errExit "failed to detect application payload content directory" $rc

  test -d "${APPDIR}" || \
    errExit "cannot access application payload content directory" 1

  INFOPLIST="${APPDIR}/Info.plist"
  test -r "${INFOPLIST}" || \
    errExit "cannot access Info.plist" 1

  # unpack the optional support directories
  local kitSupportDir="${SCRIPTDIR}/../support"
  if [ -d "${kitSupportDir}" ]
  then
    # create the support working directory
    SUPPORTDIR="${WORKDIR}/support"
    /bin/mkdir -p "$SUPPORTDIR"
    rc=$?; (( rc == 0 )) || \
      errExit "failed to create working support directory" $rc
    # copy the support structure
    /bin/cp -Rp "$kitSupportDir" "$WORKDIR"
    rc=$?; (( rc == 0 )) || \
      errExit "failed to copy kit support contents" $rc
  fi

  # get the defined application languages
  pushd "${APPDIR}" 1>/dev/null
  APPLANGS=( $(/bin/ls -1d *.lproj 2>/dev/null | /usr/bin/sed 's/.lproj//') )
  popd 1>/dev/null
  test "${#APPLANGS[@]}" -gt 0 || \
    errExit "no languages found the application!"

  # determine if Swift is supported, and if so, capture the used dylibs
  local -a frameworks=( $(/bin/ls -1 "${APPDIR}/Frameworks" 2>/dev/null) )
  local -i idx=0
  for f in "${frameworks[@]}"
  do
    if [[ $f =~ $RE_SWIFT_DYLIB ]]
    then
      SWIFT_LIBS[$idx]="$f"
      (( ++idx ))
    fi
  done
  if [ ${#SWIFT_LIBS[@]} -gt 0 ]
  then
    SWIFT_SUPPORTED=1
  fi

  # gather any extensions included in the app
  if [ -d "${APPDIR}/PlugIns" ]
  then
    PLUGINSDIR="${APPDIR}/PlugIns"
    local -a plugins=( $(/bin/ls -1 "${PLUGINSDIR}" 2>/dev/null) )
    local -i idx=0

    local -a appexList=( $(readPlistValueAsList "$DIRECTIVESPLIST" "AllowedExtensions" "$NL") )
    if [ -z "$DIRECTIVESPLIST" ]
    then
      appexList=()
    fi
    echo "Appex List: ${appexList}"
    for f in "${plugins[@]}"
    do
      if [[ $f =~ $RE_APPEX ]]
      then
        if [ "${#appexList[@]}" -gt 0 ]
        then
          echo "Checking if ${BASH_REMATCH[1]} is contained in appexList"
          containsElement "${BASH_REMATCH[1]}" "${appexList[@]}"
          if [ $? -eq 0 ]
          then
            echo "${BASH_REMATCH[1]} is contained in appexList"
            APPEXS[$idx]="${BASH_REMATCH[1]}"
            (( ++idx ))
          else
            echo "${BASH_REMATCH[1]} is NOT contained in appexList, removing ${PLUGINSDIR}/$f"
            rm -r "${PLUGINSDIR}/$f"
          fi
        else
          echo "AllowedExtensions not configured in BrandingDirectives.strings"
          APPEXS[$idx]="${BASH_REMATCH[1]}"
          (( ++idx ))
        fi
      else
        APPEXS[$idx]="${BASH_REMATCH[1]}"
        (( ++idx ))
      fi
    done

    if [ ${#APPEXS[@]} -eq 0 ]
    then
      unset PLUGINSDIR
      APPEX_PROFILE=()
    else
      if [ ${#APPEXS[@]} -ne ${#APPEX_PROFILE[@]} ]
      then
         echo -e "ERROR: Application contains ${#APPEXS[@]} app extensions but only ${#APPEX_PROFILE[@]} provisioning profile provided. ${APPEX_PROFILE[@]}"
         helpExit
      fi
    fi
  fi
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Extract Info.plist Settings
#
# Extract various Info.plist settings that describe the application.
#
# Required Global Variables:
#   INFOPLIST (read)
#   APPDIR  (read)
#   MINOSVER  (set)
#   SDKVER (set)
#   RESRULES  (set)
#   DEVICE_SUPPORTED_IPHONE  (set)
#   DEVICE_SUPPORTED_IPAD  (set)
#   DEVICE_SUPPORTED_UNIVERSAL  (set)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function extractInfoPlistSettings ()
{
  local -i rc=0
  local -i count=0
  local -i max=0

  echo "Performing version and platform checks ..."

  # get the version information
  MINOSVER=$(readPlistValue "$INFOPLIST" "MinimumOSVersion")
  rc=$?; (( rc == 0 )) || \
    errExit "failed to read minimum OS version" $rc
  SDKVER=$(readPlistValue "$INFOPLIST" "DTSDKName")
  rc=$?; (( rc == 0 )) || \
    errExit "failed to read SDK version" $rc
  if [[ $SDKVER =~ $RE_SDK ]]
  then
    SDKVER="${BASH_REMATCH[1]}"
  else
    errExit "${SDKVER} is not a recognized SDK version" 1
  fi

  # set version flags
  vercomp "$SDKVER" "7.0"; rc=$?
  case $rc in
    2) # the SDK version is less than 7; no native 7 support
       NATIVE_IOS7=0
       ;;
    *) # 7.0 SDK (or greater)
       NATIVE_IOS7=1
       ;;
  esac
  echo -e "\tSDK Version: ${SDKVER}"

  vercomp "$MINOSVER" "7.0"; rc=$?
  case $rc in
    2) # the minimum OS version is less than 7
       NATIVE_IOS6=1
       ;;
    *) # minimum 7.0 (or greater)
       NATIVE_IOS6=0
       ;;
  esac
  echo -e "\tMinimum iOS Version Support: ${MINOSVER}"

  # get the supported device types
  count=$(countPlistArrayValues "$INFOPLIST" "UIDeviceFamily" "integer")
  max=$count-1
  local -i devtype
  for i in $(eval echo {0..$max})
  do
    devtype=$(readPlistValue "$INFOPLIST" "UIDeviceFamily:${i}")
    rc=$?; (( rc == 0 )) || errExit "failed to read device type" $rc
    case $devtype in
      1) IPHONE=1
         ;;
      2) IPAD=1
         ;;
      *) errExit "unrecognized device type: $i" 1
         ;;
    esac
  done

  echo -n -e "\tSupported device types:"
  if (( IPHONE == 1 ))
  then
    DEVICE_SUPPORTED_IPHONE=1
    echo -n " iPhone"
  fi
  if (( IPAD == 1 ))
  then
    DEVICE_SUPPORTED_IPAD=1
    echo -n " iPad"
  fi
  if (( IPHONE == 1 )) && (( IPAD == 1 ))
  then
    DEVICE_SUPPORTED_UNIVERSAL=1
  fi

  echo

  # get the resource rules specification; this may be absent as the
  # resource rules have been deprecated (i.e. the goal is to sign all
  # resouces, not simply a subset defined by rules)
  RESRULES=$(readPlistValue "$INFOPLIST" "CFBundleResourceSpecification")
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Verify Bundle ID
#
# Verifies the bundle ID.  This can either be the existing bundle ID in
# the Info.plist, or it can be the value assigned to BUNDLEID.  If a
# value has been assigned to BUNDLEID, then it is used in lieu of the
# existing value.  The bundle ID must be consistent with the
# provisioning profile.
#
# Required Global Variables:
#   INFOPLIST (read)
#   PROFILEPLIST  (read)
#   BUNDLEID  (read/set)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function verifyBundleId ()
{
  echo "Verifying Bundle ID ...$BUNDLEID"

  local -i setBundleId=0

  if [ -z "$BUNDLEID" ]
  then
    # extract the existing ID
    BUNDLEID=$(readPlistValue "$INFOPLIST" "CFBundleIdentifier")
    test -n "$BUNDLEID" || \
      errExit "failed to extract Bundle ID from Info.plist" 1
  else
    # replacing the bundle ID
    setBundleId=1
  fi

  # verify the bundle ID matches the provisioning profile
  local profileAppId=$(readPlistValue "$PROFILEPLIST" "Entitlements:application-identifier")
  local -i rc=$?; (( rc == 0 )) || \
    errExit "failed to extract profile App ID" $rc

  # strip off the Team ID
  local profileBundleId="${profileAppId#*.}"

  # the profile bundle ID may be a wildcard ID (e.g. an enterprise profile
  # might specify com.example.* as the wildcard bundle ID); use case statement
  # glob matching to detect conformity
  case $BUNDLEID in
    $profileBundleId )
      # all good
      ;;
    * )
      errExit "Bundle ID ${BUNDLEID}\n\tfailed to match provisioning profile:\n\t\t${profileBundleId}" 1
      ;;
  esac

  # update the application bundle ID if necessary
  if (( setBundleId == 1 ))
  then
    echo "Updating Bundle ID: ${BUNDLEID}"
    setPlistValue "$INFOPLIST" "CFBundleIdentifier" "$BUNDLEID"
    rc=$?; (( rc == 0 )) || errExit "failed to update application bundle ID" $rc
  else
    echo "Using existing Bundle ID: ${BUNDLEID}"
  fi
  for appex in "${APPEXS[@]}"
  do
    local appexDir="${PLUGINSDIR}/${appex}.appex"
    test -d "${appexDir}" || errExit "${appexDir} plug-in directory does not exist" 1
    BUNDLE_VERSION=$(readPlistValue "$INFOPLIST" "CFBundleVersion")
    SHORT_VERSION=$(readPlistValue "$INFOPLIST" "CFBundleShortVersionString")

    # update the extension bundle ID
    echo -e "Updating ${appex} Bundle ID:\n\t${BUNDLEID}.${appex} Version:${SHORT_VERSION}"
      setPlistValue "${appexDir}/Info.plist" "CFBundleIdentifier" "${BUNDLEID}.${appex}"
      setPlistValue "${appexDir}/Info.plist" "CFBundleVersion" "${BUNDLE_VERSION}"
      setPlistValue "${appexDir}/Info.plist" "CFBundleShortVersionString" "${SHORT_VERSION}"

      # update the Display Name in Appex
      BUNDLE_DISPLAY_NAME=$(readPlistValue "$INFOPLIST" "CFBundleDisplayName")
      if [ -n "${BUNDLE_DISPLAY_NAME}" ]
      then
        setPlistValue "${appexDir}/Info.plist" "CFBundleDisplayName" "${BUNDLE_DISPLAY_NAME}"
      fi
      # update the Bundle Name in Appex
      BUNDLE_NAME=$(readPlistValue "$INFOPLIST" "CFBundleName")
      if [ -n "${BUNDLE_NAME}" ]
      then
        setPlistValue "${appexDir}/Info.plist" "CFBundleName" "${BUNDLE_NAME}"
      fi

      GROUP_IDENTIFIER=$(readPlistValue "$INFOPLIST" "GroupIdentifier")
      if [ -n "${GROUP_IDENTIFIER}" ]
      then
        setPlistValue "${appexDir}/Info.plist" "GroupIdentifier" "${GROUP_IDENTIFIER}"
      fi

      PARENT_BUNDLE_IDENTIFIER=$(readPlistValue "${appexDir}/Info.plist" "ParentAppBundleIdentifier")
      if [ -n "${PARENT_BUNDLE_IDENTIFIER}" ]
      then
        setPlistValue "${appexDir}/Info.plist" "ParentAppBundleIdentifier" "${BUNDLEID}"
      fi

    rc=$?; (( rc == 0 )) || errExit "failed to update extension bundle ID" $rc
  done

  # perhaps get the bundle name
  if [ -z "$BUNDLENAME" ]
  then
    BUNDLENAME=$(readPlistValue "$INFOPLIST" "CFBundleName")
    test -n "$BUNDLENAME" || \
      errExit "failed to extract Bundle Name from Info.plist" 1
  fi
}


function verifyAndUpdateGroupId() {
  # verify the bundle ID matches the provisioning profile
  local -i count=$(countPlistArrayValues "$PROFILEPLIST" "Entitlements:com.apple.security.application-groups" "string")
  for (( c=0; c<$count; c++ ))
  do
    val="$(readPlistValue "$PROFILEPLIST" "Entitlements:com.apple.security.application-groups:$c")"
    echo "Updating AppGroup $val in File $INFOPLIST"
    addPlistValue "$INFOPLIST" "string" "AppGroups:$c" "$val"
    rc=$?; (( rc == 0 )) || errExit "failed to update App Group ID" $rc
  done
}

function updateCFBundleVersion() {
  local key="CFBundleShortVersionString"
  local value=$(readPlistValue "$INFOPLIST" "$key")
  local oldvalue=$(readPlistValue "$INFOPLIST" "CFBundleVersion")
  echo -e "Updating CFBundleVersion to $value for Webex Teams"
  setPlistValue "$INFOPLIST" "CFBundleVersion" "$value.$oldvalue"
}

function verifyAndUpdateGroupIdentifier() {
  PARENT_GROUP_IDENTIFIER=$(readPlistValue "$INFOPLIST" "GroupIdentifier")
  if [ -z "${PARENT_GROUP_IDENTIFIER}" ]
  then
    echo "No Group Identifier found in Info.plist"
  else
    # verify the bundle ID matches the provisioning profile
    local -i count=$(countPlistArrayValues "$PROFILEPLIST" "Entitlements:com.apple.security.application-groups" "string")
    #As of now we will support only 1 entry for groups since GroupIdentifier is String
    for (( c=0; c<1; c++ ))
    do
      val="$(readPlistValue "$PROFILEPLIST" "Entitlements:com.apple.security.application-groups:$c")"
      echo "Updating GroupIdentifier $val in File $INFOPLIST"
      setPlistValue "$INFOPLIST" "GroupIdentifier" "$val"
      rc=$?; (( rc == 0 )) || errExit "failed to update App Group Identifier" $rc
    done
  fi
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Set the Application's Bundle URL Name to the Bundle Id when required.
#
# Verifies if the application does support Bundle URL schemes. If the
# application does support url schemes, then sets the name of the first
# (it would be rare, but there could be several) definition of bundle
# url schemes name to be the same as the application bundle id.
#
# Required Global Variables:
#   INFOPLIST (read)
#   BUNDLEID (read)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function applyURLSchemeChanges ()
{
  # Verify if the application supports bundle url schemes
  checkAppSupportForBundleURLSchemes
  local -i countURLTypesInfoPlist=$?
  if [ $countURLTypesInfoPlist -gt 0 ]; then

    echo "Updating application Bundle URL Name ..."
    # app does support bundle url schemes. Update the bundle url name
    # to match the app's BUNDLE ID.
    # scheme name specified in Branding Directives, replace it in Info.plist
    updateCFBundleURLNameInAppInfoPlist "$BUNDLEID"
    rc=$?; (( rc == 0 )) || errExit "failed to update application bundle URL name" $rc

  fi
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Verify Required Version Keys
#
# Verifies the Info.plist contains the required verion keys for AppStore
# distribution.
#
# Required Global Variables:
#   INFOPLIST (read)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function verifyRequiredVersionKeys ()
{
  echo "Verifying version keys for AppStore distribution ..."

  # check for the CFBundleVersion
  local key="CFBundleVersion"
  local value=$(readPlistValue "$INFOPLIST" "$key")
  test -n "$value" || \
    errExit "Info.plist must contain the ${key} key" 1

  if [[ ! $value =~ $RE_BUNDLE_VERSION ]]
  then
      errExit "Info.plist ${key}=${value}\n\tdoes not match required format\n\texpecting 1 to 4 non-negative integers separated by periods" 1
  fi
  if [[ $value =~ $RE_LEADING_ZEROS ]]
  then
      errExit "Info.plist ${key}=${value}\n\tcontains version elements with leading zeros" 1
  fi

  # check the CFBundleShortVersionString
  key="CFBundleShortVersionString"
  value=$(readPlistValue "$INFOPLIST" "$key")
  test -n "$value" || \
    errExit "Info.plist must contain the ${key} key" 1

  if [[ ! $value =~ $RE_SHORT_VERSION ]]
  then
      errExit "Info.plist ${key}=${value}\n\tdoes not match required format (#.#.#)" 1
  fi
  if [[ $value =~ $RE_LEADING_ZEROS ]]
  then
      errExit "Info.plist ${key}=${value}\n\tcontains version elements with leading zeros" 1
  fi
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Replace Embedded Mobile Profile
#
# Replaces the embedded mobile profile with the provisioning profile.
#
# Required Global Variables:
#   PROFILE  (read)
#   APPDIR  (read)
#   PLUGINSDIR  (read)
#   APPEXS  (read)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function replaceEmbeddedMobileProfile ()
{
  echo "Updating embedded mobile provisioning profile ..."

  /bin/cp "${PROFILE}" "${APPDIR}/embedded.mobileprovision"
  local -i rc=$?; (( rc == 0 )) || \
    errExit "failed to replace mobile provisioning profile" $rc

  # check for plugins

  for profile in "${APPEX_PROFILE[@]}"
  do
    IFS=':' read -ra temp <<< "$profile"
    local appex="${temp[0]}"
    local pp="${temp[1]}"


    if [ ${#temp[@]} -eq 1 ] && [ ${#APPEXS[@]} -eq 1 ]
    then
      pp="${appex}"
      appex="${APPEXS[0]}"
    fi

    local appexDir="${PLUGINSDIR}/${appex}.appex"
    test -d "${appexDir}" || errExit "${appexDir} plug-in directory does not exist" 1
    echo "Updating $pp embedded mobile provisioning profile to ${appexDir} ..."

    /bin/cp "$pp" "${appexDir}/embedded.mobileprovision"

    local -i rc=$?; (( rc == 0 )) || \
      errExit "failed to replace plug-in mobile provisioning" $rc
  done
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Strip iTunes Artwork
#
# Removes the iTunes artwork from the app directory.
#
# Required Global Variables:
#   IPAROOT  (read)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function stripITunesArtwork ()
{
  local -i notice=0;
  local -a artwork=( $(/bin/ls -1 ${IPAROOT} 2>/dev/null) )
  for f in "${artwork[@]}"
  do
    if [[ $f =~ $RE_ITUNESART ]]
    then
      if (( notice == 0 ))
      then
        echo "removing iTunes artwork ..."
        notice=1
      fi
      echo -e "\t${f}"
      /bin/rm "${IPAROOT}/${f}"
    fi
  done
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Optionally Add Swift Support
#
# Adds the SwiftSupport directory to the IPA root.
#
# Required Global Variables:
#   IPAROOT  (read)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function optionallyAddSwiftSupport ()
{
  if (( SWIFT_SUPPORTED == 1 ))
  then
    echo "Adding Swift Support libraries ..."
    SWIFTSRC="${SUPPORTDIR}/${SWIFT_SUPPORT_DIR}/iphoneos"
    SWIFTDST="${IPAROOT}/${SWIFT_SUPPORT_DIR}/iphoneos"
    if [ ! -d "$SWIFTSRC" ]; then
      SWIFTSRC="${SUPPORTDIR}/${SWIFT_SUPPORT_DIR}"
      SWIFTDST="${IPAROOT}/${SWIFT_SUPPORT_DIR}"
    fi
    test -d "$SWIFTSRC" || \
      errExit "Swift Support libraries missing" $rc

    /bin/mkdir -p "$SWIFTDST"
    local -i rc=$?; (( rc == 0 )) || \
      errExit "failed to create ${SWIFT_SUPPORT_DIR} directory" $rc

    for lib in "${SWIFT_LIBS[@]}"
    do
      cp -p "${SWIFTSRC}/${lib}" "${SWIFTDST}/${lib}"
      rc=$?; (( rc == 0 )) || \
        errExit "failed to copy Swift library '${lib}'" $rc
    done
  fi
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create Code Signing Entitlements
#
# Creates the code signing entitlements.
#
# Required Global Variables:
#   WORKDIR  (read)
#   BUNDLEID (read)
#   PROFILEPLIST  (read)
#   WEB_CREDENTIALS_ASSOCIATED_DOMAINS (read)
#   ENTITLEMENTS (set)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function createCodeSigningEntitlements
{
  echo "Creating entitlements properties list ..."

  ENTITLEMENTS="${WORKDIR}/entitlements.plist"
  $PLB -x -c "Print :Entitlements" "$PROFILEPLIST" > "$ENTITLEMENTS"
  local -i rc=$?; (( rc == 0 )) || \
    errExit "failed to extract entitlements from provisioning profile" $rc

  # extract the bundle ID from the entitilements
  local entAppId=$(readPlistValue "$ENTITLEMENTS" "application-identifier")
  rc=$?; (( rc == 0 )) || \
    errExit "failed to extract entitlements App ID" $rc

  # break it down in the team ID and bundle ID
  local entTeamId="${entAppId%%.*}"
  local entBundleId="${entAppId#*.}"

  # #IRIS-6053. The value of "keychain-access-groups" is always TEAM_ID.* which results
  # #in one app over writing data of the other app. For example EA can overwrite SaaS.
  # #This is fixed by changing the value of "keychain-access-groups" to TEAM_ID.APP_ID
  # setPlistValue "$ENTITLEMENTS" "keychain-access-groups" "$entBundleId"
  # deletePlistValue "$ENTITLEMENTS" "keychain-access-groups"
  # rc=$?; (( rc != 0 )) || \
  #   addPlistValue "$ENTITLEMENTS" "string" "keychain-access-groups" "${entAppId}"


  # the verifyBundleId function should have already verified that the
  # application bundle ID is a match for the entitlements; however, in the
  # case of a wildcard profile, the wildcard bundle ID in the entitlements
  # must be replaced with the true application bundle ID before code signing
  # (i.e. it can't be signed with a wildcard like ABCDEFGHIJ.com.example.*)
  if [ "$BUNDLEID" != "$entBundleId" ]
  then
    # update the code signing entitlements
    local entBundleId="${entTeamId}.${BUNDLEID}"
    echo -e "Updating code signing entitlements bundle ID to:\n\t${entBundleId}"
    setPlistValue "$ENTITLEMENTS" "application-identifier" "$entBundleId"
    rc=$?; (( rc == 0 )) || \
      errExit "failed to update code signing entitlements bundle ID" $rc
  fi

  # apple associated domain. Used to create association between the app and a website (or websites)
  # The association is used to share web credentials, but it also enables extra funcionality in the
  # app to AutoFill credentials, such as offering the user to store credentials the first time the user
  # logs in or generating strong passwords in the Update Password screen.
  echo -e "\tChecking for Associated Domains entitlement in profile."
  readonly NOT_FOUND="not found"
  readonly WC_ASSOCIATED_DOMS_KEY="com.apple.developer.associated-domains"
  readonly assocDomain=$(readPlistValue "$ENTITLEMENTS" "$WC_ASSOCIATED_DOMS_KEY" "$NOT_FOUND")
  if [ "$NOT_FONUD" == "$assocDomain" ]
  then
    echo -e "\t\tAssociated domains entitlement not present in profile. Skipping associated domains branding."
  else
    # The profile has the associated domains entitlement, now check if any web credentials associated
    # domains were (there can be several) specified for branding.
    if [ "${#WEB_CREDENTIALS_ASSOCIATED_DOMAINS[@]}" -gt 0 ]
    then
      echo -e "\t\tAdding branded web credentials associated domains to entitlements."

      # delete the associated-domains key. It the profile it comes as a string value, the format should be
      # an array of string values instead.
      deletePlistValue "$ENTITLEMENTS" "$WC_ASSOCIATED_DOMS_KEY"
      #/usr/libexec/PlistBuddy -c "Delete :${WC_ASSOCIATED_DOMS_KEY}" "$ENTITLEMENTS"
      rc=$?; (( rc == 0 )) || \
        errExit "failed to delete the ${WC_ASSOCIATED_DOMS_KEY} entitlement" $rc

      addPlistArray "$ENTITLEMENTS" "${WC_ASSOCIATED_DOMS_KEY}"
      #/usr/libexec/PlistBuddy -c "Add :${WC_ASSOCIATED_DOMS_KEY} array" "$ENTITLEMENTS"
      rc=$?; (( rc == 0 )) || \
        errExit "failed to re-add the ${WC_ASSOCIATED_DOMS_KEY} entitlement" $rc

      # Syntax of the associated domains as mentioned at
      # https://developer.apple.com/documentation/security/password_autofill/setting_up_an_app_s_associated_domains
      readonly wcPrefix="webcredentials:"
      local wcFullValue
      readonly wcKey="$WC_ASSOCIATED_DOMS_KEY:"
      for l in "${WEB_CREDENTIALS_ASSOCIATED_DOMAINS[@]}"
      do
        wcFullValue="${wcPrefix}${l}"
        updatePlistValue "$ENTITLEMENTS" "string" "$wcKey" "$wcFullValue"
        #/usr/libexec/PlistBuddy -c  "Add :${WC_ASSOCIATED_DOMS_KEY}: string ${wcFullValue}" "$ENTITLEMENTS"
        rc=$?; (( rc == 0 )) || \
          errExit "failed to add the domain value ${wcFullValue} to ${WC_ASSOCIATED_DOMS_KEY} entitlement" $rc

        echo -e "\t\t\tAdded web credentials associated domain to entitlements: $l."
      done
    else
      echo -e "\t\tAssociated domains entitlement present in profile but no domains were provided for branding. Skipping associated domains branding."
    fi
  fi
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Codesign App
#
# Codesigns the application, frameworks and extensions.
#
# Required Global Variables:
#   APPDIR  (read)
#   CERTNAME  (read)
#   ENTITLEMENTS (read)
#   RESRULES (read)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function codeSignApp ()
{
  echo "Codesigning the application ..."

  # remove the code signture directory
  /bin/rm -rf "${APPDIR}/_CodeSignature"

  # while code signing, the user may need to authenticate the keychain;
  # do not make more than 2 attempts
  rc=0
  local -i count=2
  if (( PROMPTS == 0 ))
  then
    count=1
  fi
  while (( count > 0 ))
  do
    if [ $rc -eq 1 ]
    then
      # The last attempt produced an error code of 1.  While there is
      # more than one reason why 1 might be returned, a reason the user
      # can resolve is re-authenticating keychain access.
      echo "The codesigning keychain appears to be locked!"

      # get the list of keychains
      local -a keychains=( $(/bin/ls -1 ${HOME}/Library/Keychains/*.keychain) )

      # remove the metadata keychain
      keychains=( ${keychains[@]/*metadata.keychain/} )
      max=${#keychains[@]}
      if (( max <= 0 ))
      then
        errExit "no valid keychains found!" 1
      else
        (( max-- ))
      fi

      # strip off the path and the keychain suffix
      for i in $(eval echo {0..$max})
      do
        keychains[$i]="$(basename ${keychains[$i]%.keychain})"
      done

      # prompt the user
      local selectedKechain
      if (( max == 0 ))
      then
        selectedKeychain="${keychains[0]}"
      else
        pickList \
          "Select the keychain that controls the credentials for '${CERTNAME}':" \
          "${keychains[@]}"
        selectedKeychain="${keychains[$?]}"
      fi

      # attempt the unlock
      $SECURITY unlock-keychain "${selectedKeychain}.keychain"
      rc=$?; (( rc == 0 )) || \
        errExit "failed to unlock the '${selectedKeychain}' keychain" $rc
    fi

    # attepmt to sign
    (( count-- ))
    rc=0
    echo "Codesigning the application. Checking SWIFT_SUPPORTED is true ..."
    # first sign the Framework libraries (but this is only necessary for Swift)
    if (( SWIFT_SUPPORTED == 1 ))
    then
      $CODESIGN -v --force --sign "$CERTNAME" "${APPDIR}/Frameworks/"*
      rc=$?
    fi
    # check for extension plugins to sign
    if (( rc == 0 ))
    then
      echo "Codesigned the frameworks ..."
      if [ -n "$PLUGINSDIR" ]
      then

        for profile in "${APPEX_PROFILE[@]}"
        do
          IFS=':' read -ra temp <<< "$profile"
          local appex="${temp[0]}"
          local pp="${temp[1]}"

          if [ ${#temp[@]} -eq 1 ] && [ ${#APPEXS[@]} -eq 1 ]
          then
            pp=${appex}
            appex=${APPEXS[0]}
          fi



          APPEX_ENTITLEMENT_PLIST="${pp}.plist"
          APPEX_ENTITLEMENT="${pp}.entitlement"
          $SECURITY cms -D -i "$pp" -o "$APPEX_ENTITLEMENT_PLIST"
          echo "Codesigning the App Extensions. Completed security cms"
          $PLB -x -c "Print :Entitlements" "$APPEX_ENTITLEMENT_PLIST" > "$APPEX_ENTITLEMENT"
          echo "Codesigning the app extensions...Updated Entitlements ${PLUGINSDIR} $CERTNAME for ${PLUGINSDIR}/${appex}.appex"
          $CODESIGN -v --force --sign "$CERTNAME" --entitlements="$APPEX_ENTITLEMENT" "${PLUGINSDIR}/${appex}.appex"
          # $CODESIGN --force --sign "$CERTNAME" "${PLUGINSDIR}/"*
          rc=$?
          echo "Codesigned the App Extensions."
        done




      fi
    else
      echo "Error Codesigning Frameworks..."
    fi

    if (( rc != 0 ))
    then
      echo "Error Codesigning the App Extensions..."
    fi
    # now sign the app
    if (( rc == 0 ))
    then
      echo "Codesigning the Application..."
      if [ -n "$RESRULES" ]
      then
        $CODESIGN --force --sign "$CERTNAME" --entitlements="$ENTITLEMENTS" \
          --resource-rules="${APPDIR}/${RESRULES}" "$APPDIR"
      else
        $CODESIGN --force --sign "$CERTNAME" --entitlements="$ENTITLEMENTS" \
          "$APPDIR"
      fi
      rc=$?; (( rc == 0 )) && count=0
    fi
  done

  (( rc == 0 )) || \
    errExit "failed to codesign application" $rc
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create App Archive
#
# Create the application archive.
#
# Required Global Variables:
#   WORKDIR  (read)
#   APPDIR  (read)
#   IPAROOT  (read)
#   BUNDLENAME  (read)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function createAppArchive ()
{
  local ipaName="${BUNDLENAME}.ipa"
  echo -e "Creating application archive ${ipaName} ..."

  if [ "${BUNDLENAME}.app" != "$(basename "$APPDIR")" ]
  then
    local oldAppDir="$APPDIR"
    local appDirName=$(dirname "$APPDIR")
    APPDIR="${appDirName}/${BUNDLENAME}.app"
    /bin/mv -v "$oldAppDir" "$APPDIR"
    rc=$?; (( rc == 0 )) || \
      errExit "failed to rename ${oldAppDir}" $rc
  fi

  pushd "$IPAROOT" 1>/dev/null
  $ZIP -qry "../${ipaName}" .
  local -i rc=$?; (( rc == 0 )) || \
    errExit "failed create application archive" $rc
  popd 1>/dev/null

  echo -e "${ipaName} created:\n\t${WORKDIR}/${ipaName}"
}
